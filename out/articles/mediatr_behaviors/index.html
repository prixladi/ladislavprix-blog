<!DOCTYPE html><html lang="en"><head><link rel="icon" href="/favicon.ico"/><link rel="apple-touch-icon" href="/apple-touch-icon.png"/><link rel="manifest" href="/site.webmanifest"/><meta name="theme-color" content="#1A202C"/><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><script>!function(){try{var d=document.documentElement.classList;d.remove('light','dark');var e=localStorage.getItem("theme");if(e){d.add(e)}else{d.add('dark');}}catch(t){}}();</script><title>MediatR behaviors</title><meta property="og:type" content="website"/><meta property="og:site_name" content="Ladislav Prix | blog"/><meta name="description" content="MediatR is a popular .NET library for in-process messaging."/><meta name="keywords" content="mediatr jimmy bogart mediator .net c# tech"/><meta property="og:url" content="https:/blog.ladislavprix.cz/articles/mediatr_behaviors"/><meta property="og:title" content="MediatR behaviors"/><meta property="og:description" content="MediatR is a popular .NET library for in-process messaging."/><meta property="og:image" content="https:/blog.ladislavprix.cz/assets/pages/mediatr_behaviors.png"/><meta property="twitter:title" content="MediatR behaviors"/><meta property="twitter:description" content="MediatR is a popular .NET library for in-process messaging."/><meta property="twitter:image" content="https:/blog.ladislavprix.cz/assets/pages/mediatr_behaviors.png"/><meta name="next-head-count" content="16"/><link rel="preload" href="/_next/static/css/5b675a2076f9da4836ca.css" as="style"/><link rel="stylesheet" href="/_next/static/css/5b675a2076f9da4836ca.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-a40ef1678bae11e696dba45124eadd70.js"></script><script src="/_next/static/chunks/webpack-90a60b87fd0d5fc150f2.js" defer=""></script><script src="/_next/static/chunks/framework-2191d16384373197bc0a.js" defer=""></script><script src="/_next/static/chunks/main-3471f9e78cb3bb918a47.js" defer=""></script><script src="/_next/static/chunks/pages/_app-98803b25c246cff05f01.js" defer=""></script><script src="/_next/static/chunks/530-6c02323afd16ead5794a.js" defer=""></script><script src="/_next/static/chunks/278-1071ef567df5f99408cf.js" defer=""></script><script src="/_next/static/chunks/355-dbd01a3e4bc3d8cc5aa1.js" defer=""></script><script src="/_next/static/chunks/pages/articles/%5Bid%5D-a80a63cb854994206d51.js" defer=""></script><script src="/_next/static/oMg-s_d43PMisYQj37Hkx/_buildManifest.js" defer=""></script><script src="/_next/static/oMg-s_d43PMisYQj37Hkx/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div><div class="content"><header><div><button class="theme-switcher"></button></div><h3 class="link back-to-link">Ladislav Prix | blog</h3><h1>MediatR behaviors</h1><div class="article-metadata"><div>üë§ <!-- -->Ladislav Prix<!-- --> ¬∑</div><div>üìÖ <!-- -->September 10, 2021<!-- --> ¬∑</div><div> üïí <!-- -->5<!-- --> min read ¬∑</div></div></header><main><div class="markdown"><p><a href="https://github.com/jbogard/MediatR" target="blank">MediatR</a> is <strong>.NET</strong> library for in-process messaging created by <a href="https://jimmybogard.com/" target="blank">Jimmy Bogard</a>, who is also the author of other popular libraries, such as <a href="https://github.com/AutoMapper/AutoMapper" target="blank">AutoMapper</a>. </p><p>The goal of this article is not to explain what <strong>MediatR</strong> is and how it works, it is best described by Jimmy in <a href="https://www.youtube.com/watch?v=SUiWfhAhgQw&amp;t" target="blank">this youtube video</a>. So following from now on it is assumed that the reader of this article already knows the basics about <strong>MediatR</strong>. The main goal of this article is to show <em>pipeline behavior</em> functionality and how to use it in your project.</p><h2>Behaviors</h2><p>Pipeline behaviors are tools to alter the behavior of the <em>request</em> before it hits its <em>handler</em>. They function on the classical pipeline principle, meaning you can do some action before then send a request to the next pipeline, and after it returns do something after. Below you can see a generic example of this principle.</p><pre><code class="language-csharp">public class MyBehavior&lt;TRequest, TResponse&gt; 
    : IPipelineBehavior&lt;TRequest, TResponse&gt;
    where TRequest : notnull
{
    public async Task&lt;TResponse&gt; Handle(
        TRequest request, 
        CancellationToken cancellationToken, 
        RequestHandlerDelegate&lt;TResponse&gt; next)
    {
        await DoBefore(cancellationToken);
        var response = await next();
        await DoAfter(cancellationToken);
        
        return response;
    }
}
</code></pre><p>You can restrict which <em>requests</em> the behavior will be applied to. For example, in the segment below this behavior will be applied only to requests that implement the <code>IInTransaction</code> interface. So this <em>behavior</em> opens transaction for every request that implements the <code>IInTransaction</code> interface and then, depending on if an <strong>exception</strong> has been thrown or not, commits or rolls back said transaction. </p><pre><code class="language-csharp">public class TransactionBehavior&lt;TRequest, TResponse&gt; 
    : IPipelineBehavior&lt;TRequest, TResponse&gt;
    where TRequest : IInTransaction
{
    private readonly DatabaseContext context;

    public TransactionBehavior(DatabaseContext context)
    {
        this.context = context;
    }

    public async Task&lt;TResponse&gt; Handle(
        TRequest request, 
        CancellationToken cancellationToken, 
        RequestHandlerDelegate&lt;TResponse&gt; next)
    {
        var transaction = await context.Database.BeginTransactionAsync(cancellationToken);
        try
        {
            var response = await next();
            await transaction.CommitAsync(cancellationToken);
            return response;
        }
        catch
        {
            await transaction.RollbackAsync(cancellationToken);
            throw;
        }
        
        return response;
    }
}
</code></pre><p>Behaviors can be added to the <em>dependency injection container</em> (<em>DI</em>) by simply registering them as open generic scoped services.</p><pre><code class="language-csharp">services.AddTransient(typeof(IPipelineBehavior&lt;,&gt;), typeof(TransactionBehavior&lt;,&gt;));
</code></pre><h2>RequestProcessors</h2><p><strong>MediatR</strong> package comes with some predefined behaviors - <code>RequestPreProcessorBehavior</code> and <code>RequestPostProcessorBehavior</code>. Those are behaviors that cover actions before respectively after the <em>request</em> is handled. Those <em>behaviors</em> are registered automatically with <strong>MeditR</strong> to <em>DI</em> and by default don&#x27;t do anything because don&#x27;t have any actions registered. </p><p>You can register this <em>pre / post</em> processor action by implementing <code>IRequestPreProcessor&lt;TRequest&gt;</code> / <code>IRequestPostProcessor&lt;TRequest&gt;</code> interface. These actions will get automatically registered into <em>DI</em> too. Below we can see an example of the <code>IRequestPreProcessor</code> that receives an array of validators of concrete <em>request</em> implementing an <code>IValidable</code> interface a performs validation for each validator. </p><pre><code class="language-csharp">public class RequestValidationPreprocessor&lt;TRequest&gt; 
    : IRequestPreProcessor&lt;TRequest&gt;
    where TRequest : IValidable
{
    private readonly IEnumerable&lt;IValidator&lt;TRequest&gt;&gt; validators;

    public RequestValidationPreprocessor(IEnumerable&lt;IValidator&lt;TRequest&gt;&gt; validators)
    {
        this.validators = validators;
    }

    public async Task Process(TRequest request, CancellationToken cancellationToken)
    {
        foreach(var validator in validators)
            await validator.ValidateAsync(request);
    }
}
</code></pre><h2>Conclusion</h2><p><strong>MediatR</strong> is a widely used library and <em>behaviors</em> are convenient tools to be used for with its basic functionality. I encourage you to read more about <strong>MediatR</strong> and try to use it in your projects too üòâ.</p></div></main><footer class="footer"><div class="markdown"><p>Copyright 2021 ¬© <a href="mailto:contact@ladislavprix.cz" target="blank">Ladislav Prix</a></p></div></footer><div style="position:fixed;bottom:50px;right:30px;cursor:pointer;transition-duration:0.2s;transition-timing-function:linear;transition-delay:0s;opacity:0;visibility:hidden;transition-property:opacity, visibility"><span>‚òùÔ∏è‚òùÔ∏è‚òùÔ∏è</span></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"article":{"title":"MediatR behaviors","metaDescription":"MediatR is a popular .NET library for in-process messaging.","keywordText":"mediatr jimmy bogart mediator .net c# tech","ogImageExtension":"png","brief":{"compiledSource":"var c=Object.defineProperty,g=Object.defineProperties;var h=Object.getOwnPropertyDescriptors;var r=Object.getOwnPropertySymbols;var n=Object.prototype.hasOwnProperty,s=Object.prototype.propertyIsEnumerable;var m=(e,t,a)=\u003et in e?c(e,t,{enumerable:!0,configurable:!0,writable:!0,value:a}):e[t]=a,p=(e,t)=\u003e{for(var a in t||(t={}))n.call(t,a)\u0026\u0026m(e,a,t[a]);if(r)for(var a of r(t))s.call(t,a)\u0026\u0026m(e,a,t[a]);return e},i=(e,t)=\u003eg(e,h(t));var u=(e,t)=\u003e{var a={};for(var o in e)n.call(e,o)\u0026\u0026t.indexOf(o)\u003c0\u0026\u0026(a[o]=e[o]);if(e!=null\u0026\u0026r)for(var o of r(e))t.indexOf(o)\u003c0\u0026\u0026s.call(e,o)\u0026\u0026(a[o]=e[o]);return a};const layoutProps={},MDXLayout=\"wrapper\";function MDXContent(a){var o=a,{components:e}=o,t=u(o,[\"components\"]);return mdx(MDXLayout,i(p(p({},layoutProps),t),{components:e,mdxType:\"MDXLayout\"}),mdx(\"p\",null,mdx(\"a\",p({parentName:\"p\"},{href:\"https://github.com/jbogard/MediatR\"}),\"MediatR\"),\" is a popular \",mdx(\"strong\",{parentName:\"p\"},\".NET\"),\" library for \",mdx(\"em\",{parentName:\"p\"},\"in-process messaging\"),\". It offers various tools to alter the \",mdx(\"em\",{parentName:\"p\"},\"behavior\"),\" of \",mdx(\"em\",{parentName:\"p\"},\"requests\"),\" with shared logic.\"))}MDXContent.isMDXComponent=!0;\n","scope":{}},"createdAt":"2021-09-10","author":"Ladislav Prix","readingTimeInMinutes":5,"content":{"compiledSource":"var m=Object.defineProperty,h=Object.defineProperties;var d=Object.getOwnPropertyDescriptors;var r=Object.getOwnPropertySymbols;var i=Object.prototype.hasOwnProperty,s=Object.prototype.propertyIsEnumerable;var p=(e,a,t)=\u003ea in e?m(e,a,{enumerable:!0,configurable:!0,writable:!0,value:t}):e[a]=t,o=(e,a)=\u003e{for(var t in a||(a={}))i.call(a,t)\u0026\u0026p(e,t,a[t]);if(r)for(var t of r(a))s.call(a,t)\u0026\u0026p(e,t,a[t]);return e},c=(e,a)=\u003eh(e,d(a));var l=(e,a)=\u003e{var t={};for(var n in e)i.call(e,n)\u0026\u0026a.indexOf(n)\u003c0\u0026\u0026(t[n]=e[n]);if(e!=null\u0026\u0026r)for(var n of r(e))a.indexOf(n)\u003c0\u0026\u0026s.call(e,n)\u0026\u0026(t[n]=e[n]);return t};const layoutProps={},MDXLayout=\"wrapper\";function MDXContent(t){var n=t,{components:e}=n,a=l(n,[\"components\"]);return mdx(MDXLayout,c(o(o({},layoutProps),a),{components:e,mdxType:\"MDXLayout\"}),mdx(\"p\",null,mdx(\"a\",o({parentName:\"p\"},{href:\"https://github.com/jbogard/MediatR\"}),\"MediatR\"),\" is \",mdx(\"strong\",{parentName:\"p\"},\".NET\"),\" library for in-process messaging created by \",mdx(\"a\",o({parentName:\"p\"},{href:\"https://jimmybogard.com/\"}),\"Jimmy Bogard\"),\", who is also the author of other popular libraries, such as \",mdx(\"a\",o({parentName:\"p\"},{href:\"https://github.com/AutoMapper/AutoMapper\"}),\"AutoMapper\"),\". \"),mdx(\"p\",null,\"The goal of this article is not to explain what \",mdx(\"strong\",{parentName:\"p\"},\"MediatR\"),\" is and how it works, it is best described by Jimmy in \",mdx(\"a\",o({parentName:\"p\"},{href:\"https://www.youtube.com/watch?v=SUiWfhAhgQw\u0026t\"}),\"this youtube video\"),\". So following from now on it is assumed that the reader of this article already knows the basics about \",mdx(\"strong\",{parentName:\"p\"},\"MediatR\"),\". The main goal of this article is to show \",mdx(\"em\",{parentName:\"p\"},\"pipeline behavior\"),\" functionality and how to use it in your project.\"),mdx(\"h2\",null,\"Behaviors\"),mdx(\"p\",null,\"Pipeline behaviors are tools to alter the behavior of the \",mdx(\"em\",{parentName:\"p\"},\"request\"),\" before it hits its \",mdx(\"em\",{parentName:\"p\"},\"handler\"),\". They function on the classical pipeline principle, meaning you can do some action before then send a request to the next pipeline, and after it returns do something after. Below you can see a generic example of this principle.\"),mdx(\"pre\",null,mdx(\"code\",o({parentName:\"pre\"},{className:\"language-csharp\"}),`public class MyBehavior\u003cTRequest, TResponse\u003e \n    : IPipelineBehavior\u003cTRequest, TResponse\u003e\n    where TRequest : notnull\n{\n    public async Task\u003cTResponse\u003e Handle(\n        TRequest request, \n        CancellationToken cancellationToken, \n        RequestHandlerDelegate\u003cTResponse\u003e next)\n    {\n        await DoBefore(cancellationToken);\n        var response = await next();\n        await DoAfter(cancellationToken);\n        \n        return response;\n    }\n}\n`)),mdx(\"p\",null,\"You can restrict which \",mdx(\"em\",{parentName:\"p\"},\"requests\"),\" the behavior will be applied to. For example, in the segment below this behavior will be applied only to requests that implement the \",mdx(\"inlineCode\",{parentName:\"p\"},\"IInTransaction\"),\" interface. So this \",mdx(\"em\",{parentName:\"p\"},\"behavior\"),\" opens transaction for every request that implements the \",mdx(\"inlineCode\",{parentName:\"p\"},\"IInTransaction\"),\" interface and then, depending on if an \",mdx(\"strong\",{parentName:\"p\"},\"exception\"),\" has been thrown or not, commits or rolls back said transaction. \"),mdx(\"pre\",null,mdx(\"code\",o({parentName:\"pre\"},{className:\"language-csharp\"}),`public class TransactionBehavior\u003cTRequest, TResponse\u003e \n    : IPipelineBehavior\u003cTRequest, TResponse\u003e\n    where TRequest : IInTransaction\n{\n    private readonly DatabaseContext context;\n\n    public TransactionBehavior(DatabaseContext context)\n    {\n        this.context = context;\n    }\n\n    public async Task\u003cTResponse\u003e Handle(\n        TRequest request, \n        CancellationToken cancellationToken, \n        RequestHandlerDelegate\u003cTResponse\u003e next)\n    {\n        var transaction = await context.Database.BeginTransactionAsync(cancellationToken);\n        try\n        {\n            var response = await next();\n            await transaction.CommitAsync(cancellationToken);\n            return response;\n        }\n        catch\n        {\n            await transaction.RollbackAsync(cancellationToken);\n            throw;\n        }\n        \n        return response;\n    }\n}\n`)),mdx(\"p\",null,\"Behaviors can be added to the \",mdx(\"em\",{parentName:\"p\"},\"dependency injection container\"),\" (\",mdx(\"em\",{parentName:\"p\"},\"DI\"),\") by simply registering them as open generic scoped services.\"),mdx(\"pre\",null,mdx(\"code\",o({parentName:\"pre\"},{className:\"language-csharp\"}),`services.AddTransient(typeof(IPipelineBehavior\u003c,\u003e), typeof(TransactionBehavior\u003c,\u003e));\n`)),mdx(\"h2\",null,\"RequestProcessors\"),mdx(\"p\",null,mdx(\"strong\",{parentName:\"p\"},\"MediatR\"),\" package comes with some predefined behaviors - \",mdx(\"inlineCode\",{parentName:\"p\"},\"RequestPreProcessorBehavior\"),\" and \",mdx(\"inlineCode\",{parentName:\"p\"},\"RequestPostProcessorBehavior\"),\". Those are behaviors that cover actions before respectively after the \",mdx(\"em\",{parentName:\"p\"},\"request\"),\" is handled. Those \",mdx(\"em\",{parentName:\"p\"},\"behaviors\"),\" are registered automatically with \",mdx(\"strong\",{parentName:\"p\"},\"MeditR\"),\" to \",mdx(\"em\",{parentName:\"p\"},\"DI\"),\" and by default don't do anything because don't have any actions registered. \"),mdx(\"p\",null,\"You can register this \",mdx(\"em\",{parentName:\"p\"},\"pre / post\"),\" processor action by implementing \",mdx(\"inlineCode\",{parentName:\"p\"},\"IRequestPreProcessor\u003cTRequest\u003e\"),\" / \",mdx(\"inlineCode\",{parentName:\"p\"},\"IRequestPostProcessor\u003cTRequest\u003e\"),\" interface. These actions will get automatically registered into \",mdx(\"em\",{parentName:\"p\"},\"DI\"),\" too. Below we can see an example of the \",mdx(\"inlineCode\",{parentName:\"p\"},\"IRequestPreProcessor\"),\" that receives an array of validators of concrete \",mdx(\"em\",{parentName:\"p\"},\"request\"),\" implementing an \",mdx(\"inlineCode\",{parentName:\"p\"},\"IValidable\"),\" interface a performs validation for each validator. \"),mdx(\"pre\",null,mdx(\"code\",o({parentName:\"pre\"},{className:\"language-csharp\"}),`public class RequestValidationPreprocessor\u003cTRequest\u003e \n    : IRequestPreProcessor\u003cTRequest\u003e\n    where TRequest : IValidable\n{\n    private readonly IEnumerable\u003cIValidator\u003cTRequest\u003e\u003e validators;\n\n    public RequestValidationPreprocessor(IEnumerable\u003cIValidator\u003cTRequest\u003e\u003e validators)\n    {\n        this.validators = validators;\n    }\n\n    public async Task Process(TRequest request, CancellationToken cancellationToken)\n    {\n        foreach(var validator in validators)\n            await validator.ValidateAsync(request);\n    }\n}\n`)),mdx(\"h2\",null,\"Conclusion\"),mdx(\"p\",null,mdx(\"strong\",{parentName:\"p\"},\"MediatR\"),\" is a widely used library and \",mdx(\"em\",{parentName:\"p\"},\"behaviors\"),\" are convenient tools to be used for with its basic functionality. I encourage you to read more about \",mdx(\"strong\",{parentName:\"p\"},\"MediatR\"),\" and try to use it in your projects too \\u{1F609}.\"))}MDXContent.isMDXComponent=!0;\n","scope":{}},"id":"mediatr_behaviors"},"settings":{"title":"Ladislav Prix | blog","footer":{"compiledSource":"var y=Object.defineProperty,l=Object.defineProperties;var m=Object.getOwnPropertyDescriptors;var p=Object.getOwnPropertySymbols;var e=Object.prototype.hasOwnProperty,i=Object.prototype.propertyIsEnumerable;var c=(t,o,a)=\u003eo in t?y(t,o,{enumerable:!0,configurable:!0,writable:!0,value:a}):t[o]=a,r=(t,o)=\u003e{for(var a in o||(o={}))e.call(o,a)\u0026\u0026c(t,a,o[a]);if(p)for(var a of p(o))i.call(o,a)\u0026\u0026c(t,a,o[a]);return t},s=(t,o)=\u003el(t,m(o));var u=(t,o)=\u003e{var a={};for(var n in t)e.call(t,n)\u0026\u0026o.indexOf(n)\u003c0\u0026\u0026(a[n]=t[n]);if(t!=null\u0026\u0026p)for(var n of p(t))o.indexOf(n)\u003c0\u0026\u0026i.call(t,n)\u0026\u0026(a[n]=t[n]);return a};const layoutProps={},MDXLayout=\"wrapper\";function MDXContent(a){var n=a,{components:t}=n,o=u(n,[\"components\"]);return mdx(MDXLayout,s(r(r({},layoutProps),o),{components:t,mdxType:\"MDXLayout\"}),mdx(\"p\",null,\"Copyright 2021 \\xA9 \",mdx(\"a\",r({parentName:\"p\"},{href:\"mailto:contact@ladislavprix.cz\"}),\"Ladislav Prix\")))}MDXContent.isMDXComponent=!0;\n","scope":{}}},"seoProps":{"title":"MediatR behaviors","metaDescription":"MediatR is a popular .NET library for in-process messaging.","metaKeywords":"mediatr jimmy bogart mediator .net c# tech","ogTitle":"MediatR behaviors","ogDescription":"MediatR is a popular .NET library for in-process messaging.","ogImage":"https:/blog.ladislavprix.cz/assets/pages/mediatr_behaviors.png","ogUrl":"https:/blog.ladislavprix.cz/articles/mediatr_behaviors","ogSiteName":"Ladislav Prix | blog"}},"__N_SSG":true},"page":"/articles/[id]","query":{"id":"mediatr_behaviors"},"buildId":"oMg-s_d43PMisYQj37Hkx","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>